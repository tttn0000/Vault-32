<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[32 PhD Thesis Writing]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>32 PhD Thesis Writing</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 06 Nov 2025 00:36:11 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 06 Nov 2025 00:36:10 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[MODULE - CBS Index Coverage, Burden, and Shift - Three-part evaluative framework for modular fit]]></title><description><![CDATA[<a data-href="Coverage" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Coverage</a>, <a data-href="Permutations" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Permutations</a>, and <a data-href="Shift" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Shift</a> are three separate but complementary measures that help assess how well a proposed module size (m, in millimetres) fits a given set of real-world product dimensions (D). All three range from 0 to 1 and are interpreted on their own and together. This can be called "CBS Index" (Coverage, Permutations, Shift). This is a efficiency-oriented evaluation approach which can work in complement to divisibility-driven discovery approaches as cross check and confirmation.Coverage tells you what share of the existing dimensions already align with the chosen module size m. In simple terms, it asks: “How many values are already on this grid without needing to change anything?” For example, if m is 50 mm, then values like 100 mm or 150 mm are perfectly aligned.Technically, a value counts as aligned if it's an exact multiple of m or, if using a tolerance rule, close enough to be treated as one. You can measure this either across all values (including repeated ones) or just once per unique dimension.Coverage is highest when many values fall directly on the grid and drops when values cluster around unrelated sizes.Permutations reflects the variety and spread of different multiples of m you would have to support if you adopt that module. It captures how many different “sizes” you’d need to produce, stock, or manage. For example, if most aligned values are just multiples of 2 and 3 (like 100 mm and 150 mm with m = 50 mm), the permutations is low. But if you have to deal with many distinct and equally common sizes (like 50 mm, 100 mm, 150 mm, ..., 500 mm), the permutations rises.There are two ways to calculate it:
Count-based: Looks at how many unique multiples are present, normalised to the possible number of multiples in your dataset’s range.
Entropy-based: Takes into account not just how many multiples there are, but how evenly they are used.
Either method shows how complex your operations might become when adopting m. High Permutations means more SKUs, documentation, and coordination.Shift tells you how far, on average, each value would need to move to align with the m grid. This is like measuring the “cost of adjustment” — whether through trimming, redesign, or retooling. If most values are already close to the grid, the shift is small; if they’re scattered far from any multiple of m, the shift is large.It’s expressed as a fraction of m but can also be shown in millimetres for clarity. A Shift of 0.04 for a 50 mm module means the average adjustment needed is 2 mm.You can calculate it across all values or just those not already aligned.
High Coverage + Low Permutations + Low Shift: Ideal. Most values already fit, they cluster in a few sizes, and very little adjustment is needed.
High Coverage + High Permutations + Low/Medium Shift: Good fit but operationally complex (many sizes to manage).
Low Coverage + Low Permutations + High Shift: Poor fit; few values align and most would need big changes.
Medium Coverage + Low Permutations + Medium Shift: Lean and efficient; a smart compromise.
Example
For module m = 50 mm and dimensions D = [100, 150, 200, 215]: Coverage: 3 out of 4 values are on-grid → 0.75
Permutations (count-based): 3 distinct multiples (2, 3, 4) out of a max of 4 → (3−1)/(4−1) = 0.667
Permutations (entropy-based): If all three multiples are equally common, entropy = max → 1.0
Shift: Only 215 is off-grid, closest multiple is 200 → shift = 15 mm. Average = 15 / 200 = 0.075, or 3.75 mm This example shows how a module can mostly fit well (high Coverage), require a moderate number of variants (Burden), and involve minimal physical change (low Shift).
The CBS Index is an evaluative framework designed to assess the practical efficiency of any given module size. The CBS Index differs fundamentally from a pure divisibility-driven discovery method in its orientation. Rather than generating candidates from data structure, it diagnoses the efficiency and manageability of any candidate. For example, a module such as 100 mm might rank highly in divisibility-driven discovery scoring because it divides a large proportion of the dataset, but a efficiency-oriented evaluation method like the CBS analysis might reveal that it creates high operational burden due to the number of multiples it entails. In this way, the CBS Index complements the DDD index by turning raw divisibility success into a practical assessment of fitness for adoption.]]></description><link>99-publish/module-cbs-index-coverage,-burden,-and-shift-three-part-evaluative-framework-for-modular-fit.html</link><guid isPermaLink="false">99 - Publish/MODULE - CBS Index Coverage, Burden, and Shift - Three-part evaluative framework for modular fit.md</guid><pubDate>Sat, 30 Aug 2025 00:00:00 GMT</pubDate></item></channel></rss>